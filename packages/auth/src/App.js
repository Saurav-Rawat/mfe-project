import React from "react";
import { Switch, Route, Router } from "react-router-dom";
import {
  StylesProvider,
  createGenerateClassName,
} from "@material-ui/core/styles";

import Signin from "./components/Signin";
import Signup from "./components/Signup";

//  we are using createGenerateClassName as we are using same styling library(material-ui) for container and
// marketing app so when in production we build the css for the application due to the use of same libraries,
// it is likely the css names generated by the library(css-in-js library is getting used inside material-ui so chances are high
// that we'll have a minified class name that could collide between container app and marketing app)
// for both the application could collide and result in conflicting css
// so we are using createGenerateClassName to prevent those classname collision
const generateClassName = createGenerateClassName({
  productionPrefix: "au", // auth
});

export default ({ history, onSignIn }) => {
  return (
    <div>
      <StylesProvider generateClassName={generateClassName}>
        {
          // router component need a object which specify which history(browser/hash/memory) to use
          // in MFe its ideal to use browser history for parent/container and for remotes we use memory history
          // as we dont want remotes/mfes to manipulate the browser url on every route change also mfe (made on react/angular/vue have different router libraries)
          // can have their different implementation of browser history so we dont know on changing the browser history from remote what modification would
          // remote apps would do to browser url
          <Router history={history}>
            <Switch>
              <Route path="/auth/signin/">
                <Signin onSignIn={onSignIn} />
              </Route>
              <Route path="/auth/signup/">
                <Signup onSignIn={onSignIn} />
              </Route>
            </Switch>
          </Router>
        }
      </StylesProvider>
    </div>
  );
};
